//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Индивидуалка_ООП
//  @ File Name : System.cpp
//  @ Date : 19.10.2018
//  @ Author : Andrew Bondar
//
//

//#include <conio.h>
#include "System.h"
#include <iostream>
#include <fstream>

void System::saveToFile()
{
    std::ofstream out;
    out.open("data");

    //std::cout << " Saving to file...\n";

    out << numberOfCategories << "\n";											//кол-во Категорий для корректного считывания данных из файла
    if (firstCategory != nullptr)												//если ссылка не ссылается на "ничто", то:
    {
        Category *link = firstCategory;
        for (int a = 0; a < numberOfCategories; a++)
        {
            out << link->getName() << " " << link->numbersOfSubcategories << "\n";	//запись информации о текущей категории

            if (link->numbersOfSubcategories != 0)								//если в категории имеются какие-нибудь подкатегории, то записать их:
            {
                Subcategory *subCatBuff = link->firstSubcategory;				//буффер для ссылки на выводимую подкатегорию
                for (int i = 0; i < link->numbersOfSubcategories; i++)			//перебираются все подкатегории в текущей категории
                {
                    out << subCatBuff->getName() << " " << subCatBuff->numberOfGoods << "\n";//вывод информации о текущей подкатегории
                    if (subCatBuff->numberOfGoods != 0)							//если есть товары в подкатегории, выводятся и они:
                    {
                        Goods *goodsBuff = subCatBuff->firstGoods;				//буффер для ссылки на выводимый товар
                        for (int k = 0; k < subCatBuff->numberOfGoods; k++)		//перебираются все товары в подкатегории
                        {
                            //вывод информации про текущий товар
                            out << goodsBuff->getName() << " " << goodsBuff->getAmountOfGoods() << " " << goodsBuff->getPriceOfGoods()<<"\n";
                            goodsBuff = goodsBuff->nextItem;					//следующий товар
                        }
                    }
                    subCatBuff = subCatBuff->nextItem;							//следующая подкатегория
                }
            }
            link = link->nextItem;												//следующая категория
        }
    }

    out.close();
}

void System::loadFromFile()
{
    std::ifstream in;
    in.open("data");

    char bufCatName[30], bufSubcatName[30], bufGoodsName[30];
    int bufCatNum=0, bufSubcatNum, bufGoodsNum, bufGoodsAmount;
    float bufGoodsPrice;

    in >> bufCatNum;

    if (bufCatNum > 0)
    {
        for (int a = 0; a < bufCatNum; a++)
        {
            in >> bufCatName >> bufSubcatNum;
            addCategory(bufCatName);

            if (bufSubcatNum > 0)
            {
                for (int b = 0; b < bufSubcatNum; b++)
                {
                    in >> bufSubcatName >> bufGoodsNum;
                    addSubcategory(bufSubcatName, bufCatName);
                    if (bufGoodsNum > 0)
                    {
                        for (int c = 0; c < bufGoodsNum; c++)
                        {
                            in >> bufGoodsName >> bufGoodsAmount >> bufGoodsPrice;
                            addGoods(bufGoodsAmount, bufGoodsPrice, bufGoodsName, bufSubcatName, bufCatName);
                        }
                    }
                }
            }
        }
    }

    in.close();
}

Category* System:: findCategory(char* categoryName)
{
    Category *result = nullptr, *link = firstCategory;

    for (int i = 0; i < numberOfCategories; i++)	//перебираются все категории, при нахождении нужной результату присваивается её ссылка
    {												//если такова не найдена-возвращается nullptr
        if (!strcmp(link->getName(), categoryName))
        {
            result = link;
        }
        else link = link->nextItem;
    }

    if (result == nullptr)
    {
        //std::cout << "Category didn`t found!\n"; //будет GUI - удалить
        //_getch();
    }

    return result;
}

Subcategory* System::findSubcategory(char* subcategoryName, char *categoryName)
{
    Category *parent = findCategory(categoryName);
    Subcategory *result = nullptr, *link;
    if (parent == nullptr)
    {
        //std::cout << "\nCategory " << categoryName << " did`nt found!"; //будет GUI - удалить
        //_getch();
    }
    else
    {
        link = parent->firstSubcategory;		//перебираются все подкатегории, при нахождении нужной результату присваивается её ссылка
        int n = parent->numbersOfSubcategories;	//если родитель(категория) или сама подкатегория не найдена-возвращается nullptr

        for (int i = 0; i < n; i++)
        {
            if (!strcmp(link->getName(), subcategoryName))
            {
                result = link;
            }
            else
            {
                link = link->nextItem;
            }
        }
    }
    return result;
}

Goods* System::findGoods(char* goodsName, char* subcategoryName, char* categoryName)
{
    Subcategory *parent = findSubcategory(subcategoryName, categoryName);
    Goods *result = nullptr, *link;
    if (parent == nullptr)
    {
        //std::cout << "\nSubcategory " << subcategoryName << " did`nt found!"; //будет GUI - удалить
        //_getch();
    }
    else
    {
        link = parent->firstGoods;					//перебираются все подкатегории, при нахождении нужной результату присваивается её ссылка
        int n = parent->numberOfGoods;				//если не найдены родительские категория/подкатегория-возвращается nullptr

        for (int i = 0; i < n; i++)
        {
            if (!strcmp(link->getName(), goodsName))
            {
                result = link;
            }
            else
            {
                link = link->nextItem;
            }
        }
    }
    return result;
}

Category* System::addCategory(char* categoryName)
{
    Category *link = firstCategory;
    Category *result=nullptr;

    if (link == nullptr) //если ссылка нулевая (создается первый элемент списка)-создаем элемент :D
    {
        firstCategory = new Category(categoryName);
        result = firstCategory;
        numberOfCategories = 1;
    }
    else
    {
        for (int i = 1; i < numberOfCategories; i++)	//перебираются все существующие категории на наличие идентичного имени
        {												//если новое имя уникально-создается категория в конце списка
            if (!strcmp(link->getName(), categoryName))
            {
                //std::cout << " \nCategoryName " << categoryName << " already exist!\n"; //будет GUI - удалить
                //_getch();
                return result;
            }
            link = link->nextItem;
        }
        if (!strcmp(link->getName(), categoryName))  //костылек, последнюю ячейку цикл не проверяет :(
        {
            //std::cout << " \nCategoryName " << categoryName << " already exist!\n"; //будет GUI - удалить
            //_getch();
            return result;
        }
        link->nextItem = new Category(categoryName);
        result = link->nextItem;
        numberOfCategories += 1;
    }
    return result;
}

Subcategory* System::addSubcategory(char* subcategoryName, char* categoryName)
{
    Category *parent = findCategory(categoryName);
    Subcategory *result=nullptr;

    if (parent==nullptr)	//проверка на успешность нахождения категории
    {
        //std::cout << "\nCategory "<<categoryName<<" did`nt found!"; //будет GUI - удалить
        //_getch();
    }
    else
    {
        Subcategory *link = parent->firstSubcategory;
        if (parent->numbersOfSubcategories == 0)
        {
            parent->firstSubcategory = new Subcategory(subcategoryName);
            result = parent->firstSubcategory;
        }
        else
        {
            for (int i = 1; i < parent->numbersOfSubcategories; i++)
            {
                if (!strcmp(link->getName(), subcategoryName))
                {
                    //std::cout << " \nSubcategory " << subcategoryName << " already exist!\n"; //будет GUI - удалить
                    //_getch();
                    return result;
                }
                link = link->nextItem;
            }
            if (!strcmp(link->getName(), subcategoryName))  //костылек, последнюю ячейку не проверяет цикл :/
            {
                //std::cout << " \nSubcategory " << subcategoryName << " already exist!\n"; //будет GUI - удалить
                //_getch();
                return result;
            }
            link->nextItem = new Subcategory(subcategoryName);
            result = link->nextItem;
        }
        parent->numbersOfSubcategories += 1;
    }
    return result;
}

Goods* System::addGoods(int amount, float price, char* goodsName, char* subcategoryName, char* categoryName)
{
    Subcategory *parent = findSubcategory(subcategoryName, categoryName);	//добавить проверку на успешность нахождения категории
    Goods *result=nullptr;

    if (parent == nullptr)
    {
        //std::cout << "\nSubcategory " << subcategoryName << " did`nt found!"; //будет GUI - удалить
        //_getch();
    }
    else
    {
        Goods *link = parent->firstGoods;
        if (parent->numberOfGoods == 0)
        {
            parent->firstGoods = new Goods(goodsName, amount, price);
            result = parent->firstGoods;
        }
        else
        {
            for (int i = 1; i < parent->numberOfGoods; i++)
            {
                if (!strcmp(link->getName(), goodsName))
                {
                    //std::cout << " \nGoods " << goodsName << " already exist!\n"; //будет GUI - удалить
                    //_getch();
                    return result;
                }
                link = link->nextItem;
            }
            if (!strcmp(link->getName(), goodsName))  //костылек, последнюю ячейку не проверяет цикл :( или не костыль?..
            {
                //std::cout << " \nGoods " << goodsName << " already exist!\n"; //будет GUI - удалить
                //_getch();
                return result;
            }
            link->nextItem = new Goods(goodsName, amount, price);
            result = link->nextItem;
        }
        parent->numberOfGoods += 1;
    }
    return result;
}

void System::deleteCategory(char* name)
{
    Category *link = firstCategory;

    if (!strcmp(link->getName(), name))
    {
        firstCategory = link->nextItem;
        link->~Category();
        numberOfCategories--;
    }
    else
    {
        for (int i = 1; i < numberOfCategories; i++)		//int i=1 чтобы nextItem не вылезал на nextitem последнего элемента
        {
            if (!strcmp(link->nextItem->getName(), name))
            {
                Category *buff = link->nextItem->nextItem;	//запихиваем в буфер ссылку на следующую после удаляемой подкатегорию
                link->nextItem->~Category();				//удаляем искомую категорию...
                link->nextItem = buff;						//присваиваем ссылку на следующую цепочку взамен удаленной подкатегории
                numberOfCategories--;
            }
        }
    }
}

void System::deleteSubcategory(char* name, char* categoryName)
{
    Category *parent = findCategory(categoryName);

    if (parent == nullptr)
    {
        //std::cout << "\nCategory " << categoryName << " didn`t found, subcategory " << name << " not deleted!"; //будет GUI - удалить
        //_getch();
    }
    else
    {
        Subcategory *link = parent->firstSubcategory;

        if (!strcmp(link->getName(), name))
        {
            parent->firstSubcategory = link->nextItem;
            link->~Subcategory();
            parent->numbersOfSubcategories--;
        }
        else
        {
            for (int i = 1; i < parent->numbersOfSubcategories; i++) //int i=1 чтобы nextItem не вылезал на nextitem последнего элемента
            {
                if (!strcmp(link->nextItem->getName(), name))
                {
                    Subcategory *buff = link->nextItem->nextItem;	//запихиваем в буфер ссылку на следующую после удаляемой подкатегорию
                    link->nextItem->~Subcategory();					//удаляем искомую подкатегорию...
                    link->nextItem = buff;							//присваиваем ссылку на следующую цепочку взамен удаленной подкатегории
                    parent->numbersOfSubcategories--;
                }
            }
        }
    }
}

void System::deleteGoods(char* name, char* subcategoryName, char* categoryName)
{
    Subcategory *parent = findSubcategory(subcategoryName, categoryName);
    if (parent == nullptr)
    {
        //std::cout << "\nSubcategory "<< categoryName << "didn`t found, goods " << name << " not deleted!"; //будет GUI - удалить
        //_getch();
    }
    else
    {
        Goods *link = parent->firstGoods;

        if (link->getName() == name)
        {
            parent->firstGoods = link->nextItem;
            link->~Goods();
            parent->numberOfGoods--;
        }
        else
        {
            for (int i = 1; i < parent->numberOfGoods; i++) //int i=1 чтобы nextItem не вылезал на nextitem последнего элемента
            {
                if (link->nextItem->getName() == name)
                {
                    Goods *buff = link->nextItem->nextItem;	//запихиваем в буфер ссылку на следующую после удаляемой подкатегорию
                    link->nextItem->~Goods();				//удаляем искомый товар...
                    link->nextItem = buff;					//присваиваем ссылку на следующую цепочку взамен удаленной подкатегории
                    parent->numberOfGoods--;
                }
            }
        }
    }
}

void System::showAllInfo() //будет GUI - удалить
{
    if (firstCategory != nullptr)												//если ссылка не ссылается на "ничто", то:
    {
        Category *link = firstCategory;
        for (int a = 0; a < numberOfCategories; a++)
        {
            //std::cout << " \n\tCategory: " << link->getName() << " (" << link->numbersOfSubcategories << ")";	//вывод информации о текущей категории

            if (link->numbersOfSubcategories != 0)								//если в категории имеются какие-нибудь подкатегории, то вывести их:
            {
                Subcategory *subCatBuff = link->firstSubcategory;				//буффер для ссылки на выводимую подкатегорию
                for (int i = 0; i < link->numbersOfSubcategories; i++)			//перебираются все подкатегории в текущей категории
                {
                    //std::cout << "\n\t\tSubcategory: " << subCatBuff->getName();//вывод информации о текущей подкатегории
                    if (subCatBuff->numberOfGoods != 0)							//если есть товары в подкатегории, выводятся и они:
                    {
                        Goods *goodsBuff = subCatBuff->firstGoods;				//буффер для ссылки на выводимый товар
                        for (int k = 0; k < subCatBuff->numberOfGoods; k++)		//перебираются все товары в подкатегории
                        {
                                                                                //вывод информации про текущий товар
                            //std::cout << "\n\t\t\tGoods: " << goodsBuff->getName() << ", amount = " << goodsBuff->getAmountOfGoods() << ", price = " << goodsBuff->getPriceOfGoods();
                            goodsBuff = goodsBuff->nextItem;					//следующий товар
                        }
                    }
                    subCatBuff = subCatBuff->nextItem;							//следующая подкатегория
                }
            }
            link = link->nextItem;												//следующая категория
        }
    }
}

System::System()
{
    numberOfCategories = 0;
    firstCategory = nullptr;
}
